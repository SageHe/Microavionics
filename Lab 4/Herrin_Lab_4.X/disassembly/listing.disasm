Disassembly Listing for Herrin_Lab_4
Generated From:
C:/Users/sageh/Documents/5067/Lab 4/Herrin_Lab_4.X/dist/default/production/Herrin_Lab_4.X.production.cof
Oct 21, 2020 5:24:46 PM

---  C:/Users/sageh/Documents/5067/Lab 4/Herrin_Sage_Lab_4.asm  -----------------------------------------
                                                  1:     ;;;;;;; ASEN 4-5067 Lab4 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  2:     ; Author: Sage Herrin
                                                  3:     ; Date  : 10/8/20
                                                  4:     ;
                                                  5:     ; DESCRIPTION
                                                  6:     ; On power up execute the following sequence:
                                                  7:     ; 	RD5 ON for ~1 second then OFF
                                                  8:     ; 	RD6 ON for ~1 second then OFF
                                                  9:     ; 	RD7 ON for ~1 second then OFF
                                                  10:    ; LOOP on the following forever:
                                                  11:    ; 	Blink "Alive" LED (RD4) ON for ~1sec then OFF for ~1sec
                                                  12:    ; 	Read input from RPG (at least every 2ms) connected to pins 
                                                  13:    ;		RD0 and RD1 and mirror the output onto pins RJ2 and RJ3
                                                  14:    ; 	ASEN5519 ONLY: Read input from baseboard RD3 button and toggle the value 
                                                  15:    ;		of RD2 such that the switch being pressed and RELEASED causes 
                                                  16:    ;		RD2 to change state from ON to OFF or OFF to ON
                                                  17:    ;	NOTE: ~1 second means +/- 100msec
                                                  18:    ;
                                                  19:    ;;;;;;; Program hierarchy ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  20:    ;
                                                  21:    ; Mainline
                                                  22:    ; Loop
                                                  23:    ; Initial 	- 	Initialize ports and perform LED sequence
                                                  24:    ; WaitXXXms	- 	Subroutine to wait XXXms
                                                  25:    ; Wait1sec 	- 	Subroutine to wait 1 sec 
                                                  26:    ; Check_SW 	- 	Subroutine to check the status of RD3 button and change RD2 (ASEN5519 ONLY)
                                                  27:    ; Check_RPG	- 	Read the values of the RPG from RD0 and RD1 and display on RJ2 and RJ3
                                                  28:    ;
                                                  29:    ;;;;;;; Assembler directives ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  30:    
                                                  31:            LIST  P=PIC18F87K22, F=INHX32, C=160, N=0, ST=OFF, MM=OFF, R=DEC, X=ON
                                                  32:    	
                                                  33:            #include P18F87K22.inc
                                                  34:    
                                                  35:    ;		MPLAB configuration directives
                                                  36:    		
                                                  37:    		CONFIG	FOSC = HS1, XINST = OFF
                                                  38:    		CONFIG	PWRTEN = ON, BOREN = ON, BORV = 1
                                                  39:    		CONFIG 	WDTEN = OFF
                                                  40:    		
                                                  41:    ;;;;;;; Hardware notes ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  42:    ;
                                                  43:    ;	RPG-A port/pin is RJ2
                                                  44:    ;	RPG-B port/pin is RJ3
                                                  45:    
                                                  46:    ;;;;;;;; Variables ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  47:    
                                                  48:            cblock  0x000		; Beginning of Access RAM
                                                  49:    	Bignum1high		;Define variables that can be changed throughout the program
                                                  50:    	Bignum1low
                                                  51:    	Bignum2high
                                                  52:    	Bignum2low
                                                  53:    	deltabn1high
                                                  54:    	deltabn1low
                                                  55:    	deltabn2high
                                                  56:    	deltabn2low
                                                  57:    	temphigh
                                                  58:    	templow
                                                  59:            COUNT			; Counter available as local to subroutines
                                                  60:            ALIVECNT		; Counter for blinking "Alive" LED
                                                  61:            BYTE			; Byte to be displayed
                                                  62:            BYTESTR:10		; Display string for binary version of BYTE
                                                  63:    	PWMDISP:11		;Display string for pwn value
                                                  64:            endc
                                                  65:    
                                                  66:    ;;;;;;; Macro definitions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  67:    
                                                  68:    ; MOVLF is a macro that puts a literal value into a GPR or SFR
                                                  69:    MOVLF   macro  literal,dest
                                                  70:            movlw  literal
                                                  71:            movwf  dest
                                                  72:    	endm
                                                  73:    ;; POINT taken from Reference: Peatman CH 7 LCD
                                                  74:    POINT   macro  stringname		; Load a string into table pointer
                                                  75:            MOVLF  high stringname, TBLPTRH	; Used to put values in program memory
                                                  76:            MOVLF  low stringname, TBLPTRL
                                                  77:            endm
                                                  78:    
                                                  79:    DISPLAY macro  register         ; Displays a given register in binary on LCD
                                                  80:            movff  register,BYTE
                                                  81:            call  ByteDisplay
                                                  82:            endm
                                                  83:    
                                                  84:    ;;;;;;; Vectors ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  85:    
                                                  86:            org  0x0000             ;Reset vector
0000  0000     NOP                                87:            nop			;One instruction cycle delay.
0002  EF0E     GOTO 0x1C                          88:            goto  Mainline		;Redirect code to the Mainline Program
0004  F000     NOP
                                                  89:    
                                                  90:            org  0x0008             ;High priority interrupt vector
0008  EF04     GOTO 0x8                           91:            goto  $                 ;Return to current program counter location
000A  F000     NOP
                                                  92:    
                                                  93:            org  0x0018             ;Low priority interrupt vector
0018  EF0C     GOTO 0x18                          94:            goto  $                 ;Return to current program counter location
001A  F000     NOP
                                                  95:    
                                                  96:    ;;;;;;; Mainline Program ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  97:    
                                                  98:    Mainline
001C  D804     RCALL 0x26                         99:            rcall  Initial          ;Jump to initialization routine
                                                  100:   Loop
001E  D8D7     RCALL 0x1CE                        101:           RCALL	Wait250ms	;Toggle RD4, i.e. 'alive' LED
0020  D8E7     RCALL 0x1F0                        102:   	RCALL	lowloop		;Set timer for duration of low portion of PWM	
0022  D8FB     RCALL 0x21A                        103:   	RCALL	Check_SW1	;Check if RD3 has been pushed	
                                                  104:           ;DISPLAY WREG
                                                  105:   	
                                                  106:   				; Add operand to finish the use of this macro 
0024  D7FC     BRA 0x1E                           107:   	bra  Loop		; Main loop should run forever after entry
                                                  108:   
                                                  109:   ;;;;;;; Initial subroutine ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  110:   ;
                                                  111:   ; This subroutine performs all initializations of variables and registers.
                                                  112:   
                                                  113:   Initial
0026  0EC0     MOVLW 0xC0                         114:   	MOVLF  0xC0,PWMDISP ;C0		;Initialize the PWMDISP string to be sent to LCD
0028  6E17     MOVWF 0x17, ACCESS
002A  0E50     MOVLW 0x50                         115:   	MOVLF  0x50,PWMDISP+1 ;P
002C  6E18     MOVWF 0x18, ACCESS
002E  0E57     MOVLW 0x57                         116:   	MOVLF  0x57,PWMDISP+2 ;W
0030  6E19     MOVWF 0x19, ACCESS
0032  0E3D     MOVLW 0x3D                         117:   	MOVLF  0x3D,PWMDISP+3 ;=
0034  6E1A     MOVWF 0x1A, ACCESS
0036  0E31     MOVLW 0x31                         118:   	MOVLF  0x31,PWMDISP+4 ;1
0038  6E1B     MOVWF 0x1B, ACCESS
003A  0E2E     MOVLW 0x2E                         119:   	MOVLF  0x2E,PWMDISP+5 ;.
003C  6E1C     MOVWF 0x1C, ACCESS
003E  0E30     MOVLW 0x30                         120:   	MOVLF  0x30,PWMDISP+6 ;0
0040  6E1D     MOVWF 0x1D, ACCESS
0042  0E30     MOVLW 0x30                         121:   	MOVLF  0x30,PWMDISP+7; 0
0044  6E1E     MOVWF 0x1E, ACCESS
0046  0E6D     MOVLW 0x6D                         122:   	MOVLF  0x6D,PWMDISP+8 ;m
0048  6E1F     MOVWF 0x1F, ACCESS
004A  0E73     MOVLW 0x73                         123:   	MOVLF  0x73,PWMDISP+9 ;s
004C  6E20     MOVWF 0x20, ACCESS
004E  0E00     MOVLW 0x0                          124:   	MOVLF  0x00,PWMDISP+10; null
0050  6E21     MOVWF 0x21, ACCESS
                                                  125:   	;MOVLF	low 0x6B90,Bignum1
                                                  126:   	;MOVLF	high 0x6B90,Bignum1+1
                                                  127:   	;MOVLF	low 0xF060,Bignum2
                                                  128:   	;MOVLF	high 0xF060,Bignum2+1
                                                  129:   deltabn1    equ	D'400'	
                                                  130:   deltabn2    equ	D'800'    
                                                  131:   on	equ	0x12			;Define necessary values and place them in proper program memory locations
0052  0E00     MOVLW 0x0                          132:   	MOVLF	D'0',on
0054  6E12     MOVWF 0x12, ACCESS
                                                  133:   pwmcount    equ	0x14
0056  0E00     MOVLW 0x0                          134:   	MOVLF	D'0',pwmcount
0058  6E14     MOVWF 0x14, ACCESS
                                                  135:   ;reg4	equ	0x07	
005A  0E6B     MOVLW 0x6B                         136:   	MOVLF	high Bignum1,Bignum1high
005C  6E00     MOVWF 0x0, ACCESS
005E  0E90     MOVLW 0x90                         137:   	MOVLF	low Bignum1,Bignum1low
0060  6E01     MOVWF 0x1, ACCESS
0062  0EF0     MOVLW 0xF0                         138:   	MOVLF	high Bignum2,Bignum2high
0064  6E02     MOVWF 0x2, ACCESS
0066  0E60     MOVLW 0x60                         139:   	MOVLF	low Bignum2,Bignum2low
0068  6E03     MOVWF 0x3, ACCESS
006A  0E01     MOVLW 0x1                          140:   	MOVLF	high deltabn1,deltabn1high
006C  6E04     MOVWF 0x4, ACCESS
006E  0E90     MOVLW 0x90                         141:   	MOVLF	low deltabn1,deltabn1low
0070  6E05     MOVWF 0x5, ACCESS
0072  0E03     MOVLW 0x3                          142:   	MOVLF	high deltabn2,deltabn2high
0074  6E06     MOVWF 0x6, ACCESS
0076  0E20     MOVLW 0x20                         143:   	MOVLF	low deltabn2,deltabn2low
0078  6E07     MOVWF 0x7, ACCESS
                                                  144:   	;MOVF	high Bignum2
007A  0E00     MOVLW 0x0                          145:   	MOVLF   B'00000000',INTCON
007C  6EF2     MOVWF INTCON, ACCESS
007E  0E85     MOVLW 0x85                         146:           MOVLF   B'10000101',T0CON       ; Set up Timer0 for a delay of 1 s
0080  6ED5     MOVWF T0CON, ACCESS
0082  0E0B     MOVLW 0xB                          147:           MOVLF   high Bignum,TMR0H       ; Writing binary 25536 to TMR0H / TMR0L
0084  6ED7     MOVWF TMR0H, ACCESS
0086  0EDC     MOVLW 0xDC                         148:           MOVLF   low Bignum,TMR0L
0088  6ED6     MOVWF TMR0, ACCESS
                                                  149:   	
008A  0EC0     MOVLW 0xC0                         150:   	MOVLF	B'11000000',TRISB
008C  6E93     MOVWF TRISB, ACCESS
008E  0E08     MOVLW 0x8                          151:   	MOVLF	B'00001000',TRISD; Set TRISD 
0090  6E95     MOVWF TRISD, ACCESS
0092  0E00     MOVLW 0x0                          152:   	MOVLF	B'00000000',TRISC; Set TRISC 
0094  6E94     MOVWF TRISC, ACCESS
0096  0E00     MOVLW 0x0                          153:   	MOVLF	B'00000000',LATD; Turn off all LEDS
0098  6E8C     MOVWF LATD, ACCESS
009A  0E00     MOVLW 0x0                          154:   	MOVLF	B'00000000',LATC
009C  6E8B     MOVWF LATC, ACCESS
009E  0E00     MOVLW 0x0                          155:   	MOVLF	B'00000000',LATB
00A0  6E8A     MOVWF LATB, ACCESS
00A2  D88D     RCALL 0x1BE                        156:   	RCALL	Wait1s; call subroutine to wait 1 second
00A4  0E20     MOVLW 0x20                         157:   	MOVLF	B'00100000',LATD; Turn ON RD5
00A6  6E8C     MOVWF LATD, ACCESS
00A8  D88A     RCALL 0x1BE                        158:   	RCALL   Wait1s; call subroutine to wait 1 second
00AA  0E00     MOVLW 0x0                          159:   	MOVLF	B'00000000',LATD; Turn OFF RD5
00AC  6E8C     MOVWF LATD, ACCESS
00AE  0E40     MOVLW 0x40                         160:   	MOVLF	B'01000000',LATD; Turn ON RD6
00B0  6E8C     MOVWF LATD, ACCESS
00B2  D885     RCALL 0x1BE                        161:   	RCALL	Wait1s; call subroutine to wait 1 second
00B4  0E00     MOVLW 0x0                          162:   	MOVLF	B'00000000',LATD; Turn OFF RD6
00B6  6E8C     MOVWF LATD, ACCESS
00B8  0E80     MOVLW 0x80                         163:   	MOVLF	B'10000000',LATD; Turn ON RD7
00BA  6E8C     MOVWF LATD, ACCESS
00BC  D880     RCALL 0x1BE                        164:   	RCALL   Wait1s; call subroutine to wait 1 second
00BE  0E00     MOVLW 0x0                          165:   	MOVLF	B'00000000',LATD; Turn OFF RD7
00C0  6E8C     MOVWF LATD, ACCESS
                                                  166:   	
00C2  0E00     MOVLW 0x0                          167:   	MOVLF   B'00000000',INTCON
00C4  6EF2     MOVWF INTCON, ACCESS
00C6  0E08     MOVLW 0x8                          168:           MOVLF   B'00001000',T0CON       ; Set up Timer0 for a delay of 10 ms
00C8  6ED5     MOVWF T0CON, ACCESS
00CA  0E63     MOVLW 0x63                         169:           MOVLF   high Bignum10ms,TMR0H       ; Writing binary 25536 to TMR0H / TMR0L
00CC  6ED7     MOVWF TMR0H, ACCESS
00CE  0EC0     MOVLW 0xC0                         170:           MOVLF   low Bignum10ms,TMR0L	; Write high byte first, then low!
00D0  6ED6     MOVWF TMR0, ACCESS
00D2  8ED5     BSF T0CON, 7, ACCESS               171:   	bsf	T0CON,7
                                                  172:   	
00D4  D81C     RCALL 0x10E                        173:   	rcall   InitLCD                 ; Initialize LCD
00D6  D884     RCALL 0x1E0                        174:           rcall   Wait10ms		; 10 ms delay subroutine
                                                  175:   	
00D8  0E02     MOVLW 0x2                          176:   	POINT   LCDcl                   ; Hello
00DA  6EF7     MOVWF TBLPTRH, ACCESS
00DC  0EEC     MOVLW 0xEC
00DE  6EF6     MOVWF TBLPTR, ACCESS
00E0  D83B     RCALL 0x158                        177:           rcall   DisplayC		; Display character subroutine
                                                  178:   	
00E2  EE00     LFSR 0, 0x17                       179:   	LFSR 0,PWMDISP
00E4  F017     NOP
00E6  D854     RCALL 0x190                        180:   	rcall DisplayV
                                                  181:   	
00E8  0E00     MOVLW 0x0                          182:   	MOVLF   B'00000000',INTCON
00EA  6EF2     MOVWF INTCON, ACCESS
00EC  0E83     MOVLW 0x83                         183:           MOVLF   B'10000011',T0CON       ; Set up Timer0 for a delay of 250 ms
00EE  6ED5     MOVWF T0CON, ACCESS
00F0  0E0B     MOVLW 0xB                          184:           MOVLF   high Bignum,TMR0H       ; Writing binary 25536 to TMR0H / TMR0L
00F2  6ED7     MOVWF TMR0H, ACCESS
00F4  0EDC     MOVLW 0xDC                         185:           MOVLF   low Bignum,TMR0L
00F6  6ED6     MOVWF TMR0, ACCESS
                                                  186:   	
00F8  0E00     MOVLW 0x0                          187:   	MOVLF	B'00000000',PIR1	;Set up timers 1,3, and 5 for use in program
00FA  6E9E     MOVWF PIR1, ACCESS
00FC  0E00     MOVLW 0x0                          188:   	MOVLF	B'00000000',PIR2
00FE  6EA1     MOVWF PIR2, ACCESS
0100  0E13     MOVLW 0x13                         189:   	MOVLF	B'00010011',T1CON
0102  6ECD     MOVWF T1CON, ACCESS
0104  0E03     MOVLW 0x3                          190:   	MOVLF	B'00000011',T3CON
0106  6EB1     MOVWF T3CON, ACCESS
0108  0E03     MOVLW 0x3                          191:   	MOVLF	B'00000011',T5CON
010A  6E7B     MOVWF T5CON, ACCESS
                                                  192:   	
010C  0012     RETURN 0                           193:           return
                                                  194:   	
                                                  195:   ;;;;;;; InitLCD subroutine ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	;THIS SUBROUTINE WAS BORROWED FROM THE LAB 4 EXAMPLE CODE
                                                  196:   ;
                                                  197:   ; InitLCD - modified version of subroutine in Reference: Peatman CH7 LCD
                                                  198:   ; Initialize the LCD.
                                                  199:   ; First wait for 0.1 second, to get past display's power-on reset time.
                                                  200:   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  201:           
                                                  202:   InitLCD
010E  0E0A     MOVLW 0xA                          203:           MOVLF  10,COUNT	    ; Wait 0.1 second for LCD to power up
0110  6E0A     MOVWF 0xA, ACCESS
                                                  204:   Loop3
0112  D866     RCALL 0x1E0                        205:           rcall  Wait10ms     ; Call wait10ms 10 times to 0.1 second
0114  060A     DECF 0xA, F, ACCESS                206:           decf  COUNT,F
0116  E1FD     BNZ 0x112                          207:           bnz	Loop3
0118  988A     BCF LATB, 4, ACCESS                208:           bcf     LATB,4	    ; RS=0 for command mode to LCD
011A  0E02     MOVLW 0x2                          209:           POINT   LCDstr      ; Set up table pointer to initialization string
011C  6EF7     MOVWF TBLPTRH, ACCESS
011E  0EDA     MOVLW 0xDA
0120  6EF6     MOVWF TBLPTR, ACCESS
0122  0008     TBLRD*                             210:           tblrd*              ; Get first byte from string into TABLAT
                                                  211:   Loop4
0124  6A8A     CLRF LATB, ACCESS                  212:   	clrf LATB	    ; First set LATB to all zero	
0126  8A8A     BSF LATB, 5, ACCESS                213:           bsf   LATB,5	    ; Drive E high - enable LCD
0128  50F5     MOVF TABLAT, W, ACCESS             214:   	movf TABLAT,W	    ; Move byte from program memory into working register
012A  0BF0     ANDLW 0xF0                         215:   	andlw 0xF0	    ; Mask to get only upper nibble
012C  38E8     SWAPF WREG, W, ACCESS              216:   	swapf WREG,W	    ; Swap so that upper nibble is in right position to move to LATB (RB0:RB3)
012E  1081     IORWF PORTB, W, ACCESS             217:   	iorwf PORTB,W	    ; Mask with the rest of PORTB to retain existing RB7:RB4 states
0130  6E8A     MOVWF LATB, ACCESS                 218:   	movwf LATB	    ; Update LATB to send upper nibble
0132  9A8A     BCF LATB, 5, ACCESS                219:           bcf   LATB,5        ; Drive E low so LCD will process input
0134  D855     RCALL 0x1E0                        220:           rcall Wait10ms      ; Wait ten milliseconds
                                                  221:   	
0136  6A8A     CLRF LATB, ACCESS                  222:   	clrf LATB	    ; Reset LATB to all zero	    
0138  8A8A     BSF LATB, 5, ACCESS                223:           bsf  LATB,5         ; Drive E high
013A  50F5     MOVF TABLAT, W, ACCESS             224:           movf TABLAT,W,0	    ; Move byte from program memory into working register
013C  0B0F     ANDLW 0xF                          225:   	andlw 0x0F	    ; Mask to get only lower nibble
013E  1081     IORWF PORTB, W, ACCESS             226:   	iorwf PORTB,W,0	    ; Mask lower nibble with the rest of PORTB
0140  6E8A     MOVWF LATB, ACCESS                 227:   	movwf LATB,0	    ; Update LATB to send lower nibble
0142  9A8A     BCF LATB, 5, ACCESS                228:           bcf   LATB,5        ; Drive E low so LCD will process input
0144  D84D     RCALL 0x1E0                        229:           rcall Wait10ms      ; Wait ten milliseconds
0146  000B     TBLRD+*                            230:           tblrd+*             ; Increment pointer and get next byte
0148  52F5     MOVF TABLAT, F, ACCESS             231:           movf  TABLAT,F      ; Check if we are done, is it zero?
014A  E1EC     BNZ 0x124                          232:           bnz	Loop4
014C  0012     RETURN 0                           233:           return
                                                  234:   	
                                                  235:   ;;;;;;; T50 subroutine ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;THIS SUBROUTINE WAS BORROWED FROM THE LAB 4 EXAMPLE CODE
                                                  236:   ;
                                                  237:   ; T50 modified version of T40 taken from Reference: Peatman CH 7 LCD
                                                  238:   ; Pause for 50 microseconds or 50/0.25 = 200 instruction cycles.
                                                  239:   ; Assumes 16/4 = 4 MHz internal instruction rate (250 ns)
                                                  240:   ; rcall(2) + movlw(1) + movwf(1) + COUNT*3 - lastBNZ(1) + return(2) = 200 
                                                  241:   ; Then COUNT = 195/3
                                                  242:   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  243:           
                                                  244:   T50
014E  0E41     MOVLW 0x41                         245:           movlw  195/3          ;Each loop L4 takes 3 ins cycles
0150  6E0A     MOVWF 0xA, ACCESS                  246:           movwf  COUNT		    
                                                  247:   L4
0152  060A     DECF 0xA, F, ACCESS                248:           decf  COUNT,F
0154  E1FE     BNZ 0x152                          249:           bnz	L4
0156  0012     RETURN 0                           250:           return
                                                  251:   ;;;;;;;;DisplayC subroutine;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; THIS SUBROUTINE WAS BORROWED FROM THE LAB 4 EXAMPLE CODE
                                                  252:   ; 
                                                  253:   ; DisplayC taken from Reference: Peatman CH7 LCD
                                                  254:   ; This subroutine is called with TBLPTR containing the address of a constant
                                                  255:   ; display string.  It sends the bytes of the string to the LCD.  The first
                                                  256:   ; byte sets the cursor position.  The remaining bytes are displayed, beginning
                                                  257:   ; at that position hex to ASCII.
                                                  258:   ; This subroutine expects a normal one-byte cursor-positioning code, 0xhh, and
                                                  259:   ; a null byte at the end of the string 0x00
                                                  260:   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  261:   
                                                  262:   DisplayC
0158  988A     BCF LATB, 4, ACCESS                263:           bcf   LATB,4		;Drive RS pin low for cursor positioning code
015A  0008     TBLRD*                             264:           tblrd*			;Get byte from string into TABLAT
015C  52F5     MOVF TABLAT, F, ACCESS             265:           movf  TABLAT,F          ;Check for leading zero byte
015E  E101     BNZ 0x162                          266:           bnz	Loop5
0160  000B     TBLRD+*                            267:           tblrd+*                 ;If zero, get next byte
                                                  268:   Loop5
0162  0EF0     MOVLW 0xF0                         269:   	movlw 0xF0
0164  168A     ANDWF LATB, F, ACCESS              270:   	andwf LATB,F		;Clear RB0:RB3, which are used to send LCD data
0166  8A8A     BSF LATB, 5, ACCESS                271:           bsf   LATB,5            ;Drive E pin high
0168  50F5     MOVF TABLAT, W, ACCESS             272:           movf TABLAT,W		;Move byte from table latch to working register
016A  0BF0     ANDLW 0xF0                         273:   	andlw 0xF0		;Mask to get only upper nibble
016C  38E8     SWAPF WREG, W, ACCESS              274:   	swapf WREG,W		;swap so that upper nibble is in right position to move to LATB (RB0:RB3)
016E  1081     IORWF PORTB, W, ACCESS             275:   	iorwf PORTB,W		;Mask to include the rest of PORTB
0170  6E8A     MOVWF LATB, ACCESS                 276:   	movwf LATB		;Send upper nibble out to LATB
0172  9A8A     BCF LATB, 5, ACCESS                277:           bcf   LATB,5            ;Drive E pin low so LCD will accept nibble
                                                  278:   	
0174  0EF0     MOVLW 0xF0                         279:   	movlw 0xF0
0176  168A     ANDWF LATB, F, ACCESS              280:   	andwf LATB,F		;Clear RB0:RB3, which are used to send LCD data
0178  8A8A     BSF LATB, 5, ACCESS                281:           bsf   LATB,5            ;Drive E pin high again
017A  50F5     MOVF TABLAT, W, ACCESS             282:           movf TABLAT,W		;Move byte from table latch to working register
017C  0B0F     ANDLW 0xF                          283:   	andlw 0x0F		;Mask to get only lower nibble
017E  1081     IORWF PORTB, W, ACCESS             284:   	iorwf PORTB,W		;Mask to include the rest of PORTB
0180  6E8A     MOVWF LATB, ACCESS                 285:   	movwf LATB		;Send lower nibble out to LATB
0182  9A8A     BCF LATB, 5, ACCESS                286:           bcf   LATB,5            ;Drive E pin low so LCD will accept nibble
0184  DFE4     RCALL 0x14E                        287:           rcall T50               ;Wait 50 usec so LCD can process
                                                  288:   	
0186  888A     BSF LATB, 4, ACCESS                289:           bsf   LATB,4            ;Drive RS pin high for displayable characters
0188  000B     TBLRD+*                            290:           tblrd+*                 ;Increment pointer, then get next byte
018A  52F5     MOVF TABLAT, F, ACCESS             291:           movf  TABLAT,F          ;Is it zero?
018C  E1EA     BNZ 0x162                          292:           bnz	Loop5
018E  0012     RETURN 0                           293:           return
                                                  294:   	
                                                  295:   ;;;;;;; DisplayV subroutine ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; THIS SUBROUTINE WAS BORROWED FROM THE LAB 4 EXAMPLE CODE
                                                  296:   ;
                                                  297:   ; DisplayV taken from Reference: Peatman CH7 LCD
                                                  298:   ; This subroutine is called with FSR0 containing the address of a variable
                                                  299:   ; display string.  It sends the bytes of the string to the LCD.  The first
                                                  300:   ; byte sets the cursor position.  The remaining bytes are displayed, beginning
                                                  301:   ; at that position.
                                                  302:   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                                  303:   
                                                  304:   DisplayV
0190  988A     BCF LATB, 4, ACCESS                305:           bcf     LATB,4          ;Drive RS pin low for cursor positioning code
                                                  306:   Loop6
0192  0EF0     MOVLW 0xF0                         307:   	movlw 0xF0
0194  168A     ANDWF LATB, F, ACCESS              308:   	andwf LATB,F		;Clear RB0:RB3, which are used to send LCD data
0196  8A8A     BSF LATB, 5, ACCESS                309:           bsf   LATB,5            ;Drive E pin high
0198  50EF     MOVF INDF0, W, ACCESS              310:           movf INDF0,W		;Move byte from table latch to working register
019A  0BF0     ANDLW 0xF0                         311:   	andlw 0xF0		;Mask to get only upper nibble
019C  38E8     SWAPF WREG, W, ACCESS              312:   	swapf WREG,W		;swap so that upper nibble is in right position to move to LATB (RB0:RB3)
019E  1081     IORWF PORTB, W, ACCESS             313:   	iorwf PORTB,W		;Mask to include the rest of PORTB
01A0  6E8A     MOVWF LATB, ACCESS                 314:   	movwf LATB		;Send upper nibble out to LATB
01A2  9A8A     BCF LATB, 5, ACCESS                315:           bcf   LATB,5            ;Drive E pin low so LCD will accept nibble
                                                  316:   	
01A4  0EF0     MOVLW 0xF0                         317:   	movlw 0xF0
01A6  168A     ANDWF LATB, F, ACCESS              318:   	andwf LATB,F		;Clear RB0:RB3, which are used to send LCD data
01A8  8A8A     BSF LATB, 5, ACCESS                319:           bsf   LATB,5            ;Drive E pin high again
01AA  50EF     MOVF INDF0, W, ACCESS              320:           movf INDF0,W		;Move byte from table latch to working register
01AC  0B0F     ANDLW 0xF                          321:   	andlw 0x0F		;Mask to get only lower nibble
01AE  1081     IORWF PORTB, W, ACCESS             322:   	iorwf PORTB,W		;Mask to include the rest of PORTB
01B0  6E8A     MOVWF LATB, ACCESS                 323:   	movwf LATB		;Send lower nibble out to LATB
01B2  9A8A     BCF LATB, 5, ACCESS                324:           bcf   LATB,5            ;Drive E pin low so LCD will accept nibble
01B4  DFCC     RCALL 0x14E                        325:           rcall T50               ;Wait 50 usec so LCD can process
                                                  326:   	  
01B6  888A     BSF LATB, 4, ACCESS                327:           bsf   LATB,4            ;Drive RS pin high for displayable characters
01B8  50EC     MOVF PREINC0, W, ACCESS            328:           movf  PREINC0,W         ;Increment pointer, then get next byte
01BA  E1EB     BNZ 0x192                          329:           bnz	Loop6
01BC  0012     RETURN 0                           330:           return	
                                                  331:   ;;;;;;; Wait1s subroutine ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; THIS SUBROUTINE WAS BORROWED FROM THE LAB 4 EXAMPLE CODE
                                                  332:   ;
                                                  333:   ; Subroutine to wait 1 second
                                                  334:   		
                                                  335:   Bignum  equ     65536-62500		;Used prescalar of 64
                                                  336:   		    
                                                  337:     
                                                  338:   Wait1s
01BE  A4F2     BTFSS INTCON, 2, ACCESS            339:           btfss 	INTCON,TMR0IF           ; Read Timer0 rollover flag and ...
01C0  D7FE     BRA 0x1BE                          340:           bra     Wait1s                  ; Loop if timer has not rolled over
01C2  0E0B     MOVLW 0xB                          341:           MOVLF  	high Bignum,TMR0H       ; Then write the timer values into
01C4  6ED7     MOVWF TMR0H, ACCESS
01C6  0EDC     MOVLW 0xDC                         342:           MOVLF  	low Bignum,TMR0L        ; the timer high and low registers
01C8  6ED6     MOVWF TMR0, ACCESS
01CA  94F2     BCF INTCON, 2, ACCESS              343:           bcf  	INTCON,TMR0IF           ; Clear Timer0 rollover flag
01CC  0012     RETURN 0                           344:           return
                                                  345:   
                                                  346:   ;;;;;;; Wait1sec subroutine ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  347:   ;
                                                  348:   ; Subroutine to wait 1 sec based on calling WaitXXXms YYY times or up to 3 nested loops
                                                  349:   				
                                                  350:   	;Need prescalar of 16
                                                  351:   
                                                  352:   Wait250ms
01CE  A4F2     BTFSS INTCON, 2, ACCESS            353:           btfss 	INTCON,TMR0IF           ; Read Timer0 rollover flag and ...
01D0  0012     RETURN 0                           354:   	return
01D2  788C     BTG LATD, 4, ACCESS                355:   	BTG	LATD,4
                                                  356:           ;bra     Wait250ms              ; Loop if timer has not rolled over
01D4  0E0B     MOVLW 0xB                          357:           MOVLF  	high Bignum,TMR0H       ; Then write the timer values into
01D6  6ED7     MOVWF TMR0H, ACCESS
01D8  0EDC     MOVLW 0xDC                         358:           MOVLF  	low Bignum,TMR0L        ; the timer high and low registers
01DA  6ED6     MOVWF TMR0, ACCESS
01DC  94F2     BCF INTCON, 2, ACCESS              359:           bcf  	INTCON,TMR0IF           ; Clear Timer0 rollover flag
01DE  0012     RETURN 0                           360:           return
                                                  361:   Bignum10ms  equ	65536-40000
                                                  362:   Wait10ms
01E0  A4F2     BTFSS INTCON, 2, ACCESS            363:           btfss 	INTCON,TMR0IF           ; Read Timer0 rollover flag and ...
01E2  D7FE     BRA 0x1E0                          364:           bra     Wait10ms                ; Loop if timer has not rolled over
01E4  0E63     MOVLW 0x63                         365:           MOVLF  	high Bignum10ms,TMR0H       ; Then write the timer values into
01E6  6ED7     MOVWF TMR0H, ACCESS
01E8  0EC0     MOVLW 0xC0                         366:           MOVLF  	low Bignum10ms,TMR0L        ; the timer high and low registers
01EA  6ED6     MOVWF TMR0, ACCESS
01EC  94F2     BCF INTCON, 2, ACCESS              367:           bcf  	INTCON,TMR0IF           ; Clear Timer0 rollover flag
01EE  0012     RETURN 0                           368:           return
                                                  369:   	
                                                  370:   Bignum1 equ	65536-38000
                                                  371:   lowloop					;Uses prescalar of 2
01F0  A09E     BTFSS PIR1, 0, ACCESS              372:   	btfss 	PIR1,TMR1IF           ; Read Timer1 rollover flag and ...
01F2  0012     RETURN 0                           373:   	return
01F4  0E04     MOVLW 0x4                          374:   	MOVLF	B'00000100',LATC
01F6  6E8B     MOVWF LATC, ACCESS
01F8  C002     MOVFF 0x2, TMR3H                   375:   	MOVFF  	Bignum2high,TMR3H      ; Then write the timer values into
01FA  FFB3     NOP
01FC  C003     MOVFF 0x3, TMR3                    376:           MOVFF  	Bignum2low,TMR3L       ; the timer high and low registers
01FE  FFB2     NOP
0200  92A1     BCF PIR2, 1, ACCESS                377:   	bcf	PIR2,TMR3IF
0202  D802     RCALL 0x208                        378:   	rcall	highloop
                                                  379:           ;bra     lowloop                     ; Loop if timer has not rolled over
                                                  380:   	;MOVLF	B'00000100',LATC
                                                  381:           ;MOVLF  	high Bignum1,TMR1H      ; Then write the timer values into
                                                  382:           ;MOVLF  	low Bignum1,TMR1L       ; the timer high and low registers
0204  909E     BCF PIR1, 0, ACCESS                383:           bcf  	PIR1,TMR1IF           ; Clear Timer1 rollover flag
                                                  384:   	;MOVLF	B'00000001',T3CON
                                                  385:   	;rcall	highloop
0206  0012     RETURN 0                           386:           return
                                                  387:   Bignum2 equ	65536-4000	
                                                  388:   highloop
0208  A2A1     BTFSS PIR2, 1, ACCESS              389:   	btfss	PIR2,TMR3IF
020A  D7FE     BRA 0x208                          390:   	bra	highloop
020C  0E00     MOVLW 0x0                          391:   	MOVLF	B'00000000',LATC        ; Read Timer3 rollover flag and ...
020E  6E8B     MOVWF LATC, ACCESS
                                                  392:   		                        ; Loop if timer has not rolled over
0210  C000     MOVFF 0x0, TMR1H                   393:           MOVFF  	Bignum1high,TMR1H      ; Then write the timer values into
0212  FFCF     NOP
0214  C003     MOVFF 0x3, TMR1                    394:           MOVFF  	Bignum2low,TMR1L       ; the timer high and low registers
0216  FFCE     NOP
                                                  395:   			                ; Clear Timer3 rollover flag
0218  0012     RETURN 0                           396:           return
                                                  397:   	;btfss	PIR2,TMR3IF
                                                  398:   	;bra	highloop
                                                  399:   	;MOVLF	B'00000000',LATC        ; Read Timer3 rollover flag and ...
                                                  400:   		                        ; Loop if timer has not rolled over
                                                  401:           ;MOVLF  	high Bignum1,TMR1H      ; Then write the timer values into
                                                  402:           ;MOVLF  	low Bignum1,TMR1L       ; the timer high and low registers
                                                  403:   			                ; Clear Timer3 rollover flag
                                                  404:           ;return
                                                  405:   	
                                                  406:   Check_SW1
                                                  407:   	;BRA	pwmc
021A  A683     BTFSS PORTD, 3, ACCESS             408:   	BTFSS	PORTD,3	; Add code here
021C  D009     BRA 0x230                          409:   	BRA	ds
021E  B612     BTFSC 0x12, 3, ACCESS              410:   	BTFSC	on,3
0220  D007     BRA 0x230                          411:   	BRA	ds
0222  0E15     MOVLW 0x15                         412:   	MOVLF  	high Bignum3,TMR5H       ; Then write the timer values into
0224  6E7D     MOVWF TMR5H, ACCESS
0226  0EA0     MOVLW 0xA0                         413:           MOVLF  	low Bignum3,TMR5L   
0228  6E7C     MOVWF TMR5, ACCESS
022A  D808     RCALL 0x23C                        414:   	RCALL	Debounce
022C  0E08     MOVLW 0x8                          415:   	MOVLF	B'00001000',on
022E  6E12     MOVWF 0x12, ACCESS
                                                  416:   ds
0230  5083     MOVF PORTD, W, ACCESS              417:   	MOVF	PORTD,0	
0232  0B08     ANDLW 0x8                          418:   	ANDLW	B'00001000'
0234  5C12     SUBWF 0x12, W, ACCESS              419:   	SUBWF	on,0
0236  B6E8     BTFSC WREG, 3, ACCESS              420:   	BTFSC	WREG,3
0238  D805     RCALL 0x244                        421:   	RCALL	pwmc
023A  0012     RETURN 0                           422:   		return
                                                  423:   Bignum3	equ	65536-60000		
                                                  424:   Debounce
023C  A2BA     BTFSS PIR5, 1, ACCESS              425:   	btfss 	PIR5,TMR5IF           ; Read Timer0 rollover flag and ...
023E  D7FE     BRA 0x23C                          426:   	bra Debounce
                                                  427:   			              ; Loop if timer has not rolled over
                                                  428:           ;MOVLF  	high Bignum3,TMR5H       ; Then write the timer values into
                                                  429:           ;MOVLF  	low Bignum3,TMR5L        ; the timer high and low registers
0240  92BA     BCF PIR5, 1, ACCESS                430:           bcf  	PIR5,TMR5IF           ; Clear Timer0 rollover flag
0242  0012     RETURN 0                           431:           return
                                                  432:   		;return
                                                  433:   
                                                  434:   ;Subroutine to increase duty cycle of PWM by adding 0.2ms to the high portion and subtracting 0.2ms from the low portion to keep the 
                                                  435:   ;period constant at 20ms		
                                                  436:   pwmc
0244  748C     BTG LATD, 2, ACCESS                437:   	BTG	LATD,2		    ;If RD3 is pressed and released, increment the high portion of pwm by 0.2ms
                                                  438:   	;MOVLW	B'00000100'	    ;and decrement low portion of pwm by 0.2ms
                                                  439:   	;cpfslt	pwmcount,0
                                                  440:   	;bra	qr
                                                  441:   	;clrf	WREG
                                                  442:   	;MOVLW	B'00000101'
                                                  443:   	;cpfslt	pwmcount,0
                                                  444:   	;bra	ps
0246  5001     MOVF 0x1, W, ACCESS                445:   	MOVF	Bignum1low,0
0248  2405     ADDWF 0x5, W, ACCESS               446:   	ADDWF	deltabn1low,0
024A  6E01     MOVWF 0x1, ACCESS                  447:   	MOVWF	Bignum1low,0
024C  5000     MOVF 0x0, W, ACCESS                448:   	MOVF	Bignum1high,0
024E  2004     ADDWFC 0x4, W, ACCESS              449:   	ADDWFC	deltabn1high,0
0250  6E00     MOVWF 0x0, ACCESS                  450:   	MOVWF	Bignum1high,0
0252  5007     MOVF 0x7, W, ACCESS                451:   	MOVF	deltabn2low,0
0254  5C03     SUBWF 0x3, W, ACCESS               452:   	SUBWF	Bignum2low,0
0256  6E03     MOVWF 0x3, ACCESS                  453:   	MOVWF	Bignum2low,0
0258  5002     MOVF 0x2, W, ACCESS                454:   	MOVF	Bignum2high,0
025A  5406     SUBFWB 0x6, W, ACCESS              455:   	SUBFWB	deltabn2high,0
025C  6E02     MOVWF 0x2, ACCESS                  456:   	MOVWF	Bignum2high,0
025E  0E04     MOVLW 0x4                          457:   	MOVLW	B'00000100'	    ;Check if the pwm is ready to be reset to high for 1ms and low for 19ms yet
0260  6014     CPFSLT 0x14, ACCESS                458:   	cpfslt	pwmcount,0
0262  D008     BRA 0x274                          459:   	bra	qr
0264  2A1D     INCF 0x1D, F, ACCESS               460:   	INCF	PWMDISP+6,F
0266  2A1D     INCF 0x1D, F, ACCESS               461:   	INCF	PWMDISP+6,F
0268  EE00     LFSR 0, 0x17                       462:   	LFSR	0,PWMDISP
026A  F017     NOP
026C  DF91     RCALL 0x190                        463:   	rcall	DisplayV
026E  2A14     INCF 0x14, F, ACCESS               464:   	INCF	pwmcount,1
0270  6A12     CLRF 0x12, ACCESS                  465:   	CLRF	on
0272  0012     RETURN 0                           466:   	return
                                                  467:   	
                                                  468:   qr
0274  6214     CPFSEQ 0x14, ACCESS                469:   	cpfseq	pwmcount,0	    ;Adusting LCD to change from 1.80 to 2.00 when appropriate
0276  D00B     BRA 0x28E                          470:   	bra	ps
0278  2A1B     INCF 0x1B, F, ACCESS               471:   	INCF	PWMDISP+4
027A  0E30     MOVLW 0x30                         472:   	MOVLF	0x30,PWMDISP+6
027C  6E1D     MOVWF 0x1D, ACCESS
027E  0E30     MOVLW 0x30                         473:   	MOVLF	0x30,PWMDISP+6
0280  6E1D     MOVWF 0x1D, ACCESS
0282  EE00     LFSR 0, 0x17                       474:   	LFSR	0,PWMDISP
0284  F017     NOP
0286  DF84     RCALL 0x190                        475:   	rcall	DisplayV
0288  2A14     INCF 0x14, F, ACCESS               476:   	INCF	pwmcount,1
028A  6A12     CLRF 0x12, ACCESS                  477:   	clrf	on
028C  0012     RETURN 0                           478:   	return
                                                  479:   ps
028E  0E6B     MOVLW 0x6B                         480:   	MOVLF	high Bignum1,Bignum1high    ;Reset pwm to 1ms high and 19ms low from 2ms high and 18ms low
0290  6E00     MOVWF 0x0, ACCESS
0292  0E90     MOVLW 0x90                         481:   	MOVLF	low Bignum1,Bignum1low
0294  6E01     MOVWF 0x1, ACCESS
0296  0EF0     MOVLW 0xF0                         482:   	MOVLF	high Bignum2,Bignum2high
0298  6E02     MOVWF 0x2, ACCESS
029A  0E60     MOVLW 0x60                         483:   	MOVLF	low Bignum2,Bignum2low
029C  6E03     MOVWF 0x3, ACCESS
029E  0E31     MOVLW 0x31                         484:   	MOVLF	0x31,PWMDISP+4
02A0  6E1B     MOVWF 0x1B, ACCESS
02A2  EE00     LFSR 0, 0x17                       485:   	LFSR	0,PWMDISP   
02A4  F017     NOP
02A6  DF74     RCALL 0x190                        486:   	rcall	DisplayV
02A8  6A14     CLRF 0x14, ACCESS                  487:   	clrf	pwmcount
02AA  6A12     CLRF 0x12, ACCESS                  488:   	clrf	on
02AC  0012     RETURN 0                           489:   	return
                                                  490:   										;THIS SUBROUTINE WAS BORROWED FROM THE LAB 4 EXAMPLE CODE
                                                  491:   ByteDisplay
02AE  0E02     MOVLW 0x2                          492:           POINT   LCDcl                 ;Display "BYTE="
02B0  6EF7     MOVWF TBLPTRH, ACCESS
02B2  0EEC     MOVLW 0xEC
02B4  6EF6     MOVWF TBLPTR, ACCESS
02B6  DF50     RCALL 0x158                        493:           rcall   DisplayC
02B8  EE00     LFSR 0, 0x15                       494:           lfsr    0,BYTESTR+8
02BA  F015     NOP
                                                  495:   L10
02BC  6AE8     CLRF WREG, ACCESS                  496:             clrf  WREG
02BE  320C     RRCF 0xC, F, ACCESS                497:             rrcf  BYTE,F                 ;Move bit into carry
02C0  36E8     RLCF WREG, F, ACCESS               498:             rlcf  WREG,F                 ;and from there into WREG
02C2  0930     IORLW 0x30                         499:             iorlw 0x30                   ;Convert to ASCII
02C4  6EED     MOVWF POSTDEC0, ACCESS             500:             movwf POSTDEC0               ; and move to string
02C6  50E9     MOVF FSR0, W, ACCESS               501:             movf  FSR0L,W                ;Done?
02C8  080D     SUBLW 0xD                          502:             sublw low BYTESTR
02CA  E1F8     BNZ 0x2BC                          503:           bnz	L10
                                                  504:   
02CC  EE00     LFSR 0, 0xD                        505:           lfsr    0,BYTESTR              ;Set pointer to display string
02CE  F00D     NOP
02D0  0EC0     MOVLW 0xC0                         506:           MOVLF   0xc0,BYTESTR           ;Add cursor-positioning code
02D2  6E0D     MOVWF 0xD, ACCESS
02D4  6A16     CLRF 0x16, ACCESS                  507:           clrf    BYTESTR+9              ;and end-of-string terminator
02D6  DF5C     RCALL 0x190                        508:           rcall   DisplayV
02D8  0012     RETURN 0                           509:           return
                                                  510:   ;;;;;;; Constant strings ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
02DA  3233     RRCF 0x33, F, ACCESS               511:   LCDstr  db  0x33,0x32,0x28,0x01,0x0c,0x06,0x00  ;Initialization string for LCD
02DC  0128     MOVLB 0x8
02DE  060C     DECF 0xC, F, ACCESS
02E0  0000     NOP
02E2  4280     RRNCF PORTA, F, ACCESS             512:   BYTE_1  db  "\x80BYTE=   \x00"         ;Write "BYTE=" to first line of LCD
02E4  5459     SUBFWB 0x59, W, ACCESS
02E6  3D45     INCFSZ 0x45, W, BANKED
02E8  2020     ADDWFC 0x20, W, ACCESS
02EC  4180     RRNCF 0x80, W, BANKED              513:   LCDcl   db  "\x80ASEN 5067   \x00"
02EE  4553     RLNCF 0x53, W, BANKED
02F0  204E     ADDWFC 0x4E, W, ACCESS
02F2  3035     RRCF 0x35, W, ACCESS
02F4  3736     RLCF 0x36, F, BANKED
02F6  2020     ADDWFC 0x20, W, ACCESS
02FA  4880     INFSNZ PORTA, W, ACCESS            514:   LCDs    db  "\x80Hello\x00"
02FC  6C65     NEGF BAUDCON1, ACCESS
02FE  6F6C     MOVWF 0x6C, BANKED
0300  0000     NOP
0302  57C0     SUBFWB 0xC0, F, BANKED             515:   LCDs2   db  "\xC0World!\x00"
0304  726F     BTG CCPR7, 1, ACCESS
0306  646C     CPFSGT PR4, ACCESS
                                                  516:   ;;;;;;; End of Program ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  517:           end
