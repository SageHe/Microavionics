MPASM 5.84             HERRIN_SAGE_LAB_4.ASM   10-27-2020  7:38:53         PAGE  1


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00001 ;;;;;;; ASEN 4-5067 Lab4 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                      00002 ; Author: Sage Herrin
                      00003 ; Date  : 10/8/20
                      00004 ;
                      00005 ; DESCRIPTION
                      00006 ; On power up execute the following sequence:
                      00007 ;       RD5 ON for ~1 second then OFF
                      00008 ;       RD6 ON for ~1 second then OFF
                      00009 ;       RD7 ON for ~1 second then OFF
                      00010 ; LOOP on the following forever:
                      00011 ;       Blink "Alive" LED (RD4) ON for ~1sec then OFF for ~1sec
                      00012 ;       Read input from RPG (at least every 2ms) connected to pins 
                      00013 ;               RD0 and RD1 and mirror the output onto pins RJ2 and RJ3
                      00014 ;       ASEN5519 ONLY: Read input from baseboard RD3 button and toggle the value 
                      00015 ;               of RD2 such that the switch being pressed and RELEASED causes 
                      00016 ;               RD2 to change state from ON to OFF or OFF to ON
                      00017 ;       NOTE: ~1 second means +/- 100msec
                      00018 ;
                      00019 ;;;;;;; Program hierarchy ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                      00020 ;
                      00021 ; Mainline
                      00022 ; Loop
                      00023 ; Initial       -       Initialize ports and perform LED sequence
                      00024 ; WaitXXXms     -       Subroutine to wait XXXms
                      00025 ; Wait1sec      -       Subroutine to wait 1 sec 
                      00026 ; Check_SW      -       Subroutine to check the status of RD3 button and change RD2 (ASEN5519 ONLY)
                      00027 ; Check_RPG     -       Read the values of the RPG from RD0 and RD1 and display on RJ2 and RJ3
                      00028 ;
                      00029 ;;;;;;; Assembler directives ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                      00030 
                      00031         LIST  P=PIC18F87K22, F=INHX32, C=160, N=0, ST=OFF, MM=OFF, R=DEC, X=ON
                      00032         
                      00033         #include P18F87K22.inc
                      00001         LIST
                      00002 
                      00003 ;==========================================================================
                      00004 ; Build date : Mar 17 2019
                      00005 ;  MPASM PIC18F87K22 processor include
                      00006 ; 
                      00007 ;  (c) Copyright 1999-2019 Microchip Technology, All rights reserved
                      00008 ;==========================================================================
                      00009 
                      02986         LIST
                      00034 
                      00035 ;               MPLAB configuration directives
                      00036                 
                      00037                 CONFIG  FOSC = HS1, XINST = OFF
                      00038                 CONFIG  PWRTEN = ON, BOREN = ON, BORV = 1
                      00039                 CONFIG  WDTEN = OFF
                      00040                 
                      00041 ;;;;;;; Hardware notes ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                      00042 ;
                      00043 ;       RPG-A port/pin is RJ2
                      00044 ;       RPG-B port/pin is RJ3
                      00045 
                      00046 ;;;;;;;; Variables ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                      00047 
                      00048         cblock  0x000           ; Beginning of Access RAM
  00000000            00049         Bignum1high             ;Define variables that can be changed throughout the program
  00000001            00050         Bignum1low
  00000002            00051         Bignum2high
  00000003            00052         Bignum2low
  00000004            00053         deltabn1high
  00000005            00054         deltabn1low
  00000006            00055         deltabn2high
  00000007            00056         deltabn2low
  00000008            00057         temphigh
  00000009            00058         templow
  0000000A            00059         COUNT                   ; Counter available as local to subroutines
  0000000B            00060         ALIVECNT                ; Counter for blinking "Alive" LED
  0000000C            00061         BYTE                    ; Byte to be displayed
  0000000D            00062         BYTESTR:10              ; Display string for binary version of BYTE
  00000017            00063         PWMDISP:11              ;Display string for pwn value
                      00064         endc
                      00065 
                      00066 ;;;;;;; Macro definitions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                      00067 
                      00068 ; MOVLF is a macro that puts a literal value into a GPR or SFR
                      00069 MOVLF   macro  literal,dest
                      00070         movlw  literal
                      00071         movwf  dest
                      00072         endm
                      00073 ;; POINT taken from Reference: Peatman CH 7 LCD
                      00074 POINT   macro  stringname               ; Load a string into table pointer
                      00075         MOVLF  high stringname, TBLPTRH ; Used to put values in program memory
                      00076         MOVLF  low stringname, TBLPTRL
                      00077         endm
                      00078 
                      00079 DISPLAY macro  register         ; Displays a given register in binary on LCD
                      00080         movff  register,BYTE
                      00081         call  ByteDisplay
                      00082         endm
                      00083 
                      00084 ;;;;;;; Vectors ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                      00085 
                      00086         org  0x0000             ;Reset vector
000000 0000           00087         nop                     ;One instruction cycle delay.
000002 EF?? F???      00088         goto  Mainline          ;Redirect code to the Mainline Program
                      00089 
                      00090         org  0x0008             ;High priority interrupt vector
000008 EF?? F???      00091         goto  $                 ;Return to current program counter location
                      00092 
                      00093         org  0x0018             ;Low priority interrupt vector
000018 EF?? F???      00094         goto  $                 ;Return to current program counter location
                      00095 
                      00096 ;;;;;;; Mainline Program ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                      00097 
00001C                00098 Mainline
00001C D???           00099         rcall  Initial          ;Jump to initialization routine
00001E                00100 Loop
00001E D???           00101         RCALL   Wait250ms       ;Toggle RD4, i.e. 'alive' LED
000020 D???           00102         RCALL   lowloop         ;Set timer for duration of low portion of PWM   
000022 D???           00103         RCALL   Check_SW1       ;Check if RD3 has been pushed   
                      00104         ;DISPLAY WREG
                      00105         
                      00106                                 ; Add operand to finish the use of this macro 
000024 D???           00107         bra  Loop               ; Main loop should run forever after entry
                      00108 
                      00109 ;;;;;;; Initial subroutine ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                      00110 ;
                      00111 ; This subroutine performs all initializations of variables and registers.
                      00112 
000026                00113 Initial
                      00114         MOVLF  0xC0,PWMDISP ;C0         ;Initialize the PWMDISP string to be sent to LCD
000026 0EC0               M         movlw  0xC0
000028 6E17               M         movwf  PWMDISP
                      00115         MOVLF  0x50,PWMDISP+1 ;P
00002A 0E50               M         movlw  0x50
00002C 6E18               M         movwf  PWMDISP+1
                      00116         MOVLF  0x57,PWMDISP+2 ;W
00002E 0E57               M         movlw  0x57
000030 6E19               M         movwf  PWMDISP+2
                      00117         MOVLF  0x3D,PWMDISP+3 ;=
000032 0E3D               M         movlw  0x3D
000034 6E1A               M         movwf  PWMDISP+3
                      00118         MOVLF  0x31,PWMDISP+4 ;1
000036 0E31               M         movlw  0x31
000038 6E1B               M         movwf  PWMDISP+4
                      00119         MOVLF  0x2E,PWMDISP+5 ;.
00003A 0E2E               M         movlw  0x2E
00003C 6E1C               M         movwf  PWMDISP+5
                      00120         MOVLF  0x30,PWMDISP+6 ;0
00003E 0E30               M         movlw  0x30
000040 6E1D               M         movwf  PWMDISP+6
                      00121         MOVLF  0x30,PWMDISP+7; 0
000042 0E30               M         movlw  0x30
000044 6E1E               M         movwf  PWMDISP+7
                      00122         MOVLF  0x6D,PWMDISP+8 ;m
000046 0E6D               M         movlw  0x6D
000048 6E1F               M         movwf  PWMDISP+8
                      00123         MOVLF  0x73,PWMDISP+9 ;s
00004A 0E73               M         movlw  0x73
00004C 6E20               M         movwf  PWMDISP+9
                      00124         MOVLF  0x00,PWMDISP+10; null
00004E 0E00               M         movlw  0x00
000050 6E21               M         movwf  PWMDISP+10
                      00125         ;MOVLF  low 0x6B90,Bignum1
                      00126         ;MOVLF  high 0x6B90,Bignum1+1
                      00127         ;MOVLF  low 0xF060,Bignum2
                      00128         ;MOVLF  high 0xF060,Bignum2+1
  00000190            00129 deltabn1    equ D'400'  
  00000320            00130 deltabn2    equ D'800'    
  00000012            00131 on      equ     0x12                    ;Define necessary values and place them in proper program memory locations
                      00132         MOVLF   D'0',on
000052 0E00               M         movlw  D'0'
000054 6E12               M         movwf  on
  00000014            00133 pwmcount    equ 0x14
                      00134         MOVLF   D'0',pwmcount
000056 0E00               M         movlw  D'0'
000058 6E14               M         movwf  pwmcount
                      00135 ;reg4   equ     0x07    
                      00136         MOVLF   high Bignum1,Bignum1high
00005A 0E6B               M         movlw  high Bignum1
00005C 6E00               M         movwf  Bignum1high
                      00137         MOVLF   low Bignum1,Bignum1low
00005E 0E90               M         movlw  low Bignum1
000060 6E01               M         movwf  Bignum1low
                      00138         MOVLF   high Bignum2,Bignum2high
000062 0EF0               M         movlw  high Bignum2
000064 6E02               M         movwf  Bignum2high
                      00139         MOVLF   low Bignum2,Bignum2low
000066 0E60               M         movlw  low Bignum2
000068 6E03               M         movwf  Bignum2low
                      00140         MOVLF   high deltabn1,deltabn1high
00006A 0E01               M         movlw  high deltabn1
00006C 6E04               M         movwf  deltabn1high
                      00141         MOVLF   low deltabn1,deltabn1low
00006E 0E90               M         movlw  low deltabn1
000070 6E05               M         movwf  deltabn1low
                      00142         MOVLF   high deltabn2,deltabn2high
000072 0E03               M         movlw  high deltabn2
000074 6E06               M         movwf  deltabn2high
                      00143         MOVLF   low deltabn2,deltabn2low
000076 0E20               M         movlw  low deltabn2
000078 6E07               M         movwf  deltabn2low
                      00144         ;MOVF   high Bignum2
                      00145         MOVLF   B'00000000',INTCON
00007A 0E00               M         movlw  B'00000000'
00007C 6EF2               M         movwf  INTCON
                      00146         MOVLF   B'10000101',T0CON       ; Set up Timer0 for a delay of 1 s
00007E 0E85               M         movlw  B'10000101'
000080 6ED5               M         movwf  T0CON
                      00147         MOVLF   high Bignum,TMR0H       ; Writing binary 25536 to TMR0H / TMR0L
000082 0E0B               M         movlw  high Bignum
000084 6ED7               M         movwf  TMR0H
                      00148         MOVLF   low Bignum,TMR0L
000086 0EDC               M         movlw  low Bignum
000088 6ED6               M         movwf  TMR0L
                      00149         
                      00150         MOVLF   B'11000000',TRISB
00008A 0EC0               M         movlw  B'11000000'
00008C 6E93               M         movwf  TRISB
                      00151         MOVLF   B'00001000',TRISD; Set TRISD 
00008E 0E08               M         movlw  B'00001000'
000090 6E95               M         movwf  TRISD
                      00152         MOVLF   B'00000000',TRISC; Set TRISC 
000092 0E00               M         movlw  B'00000000'
000094 6E94               M         movwf  TRISC
                      00153         MOVLF   B'00000000',LATD; Turn off all LEDS
000096 0E00               M         movlw  B'00000000'
000098 6E8C               M         movwf  LATD
                      00154         MOVLF   B'00000000',LATC
00009A 0E00               M         movlw  B'00000000'
00009C 6E8B               M         movwf  LATC
                      00155         MOVLF   B'00000000',LATB
00009E 0E00               M         movlw  B'00000000'
0000A0 6E8A               M         movwf  LATB
0000A2 D???           00156         RCALL   Wait1s; call subroutine to wait 1 second
                      00157         MOVLF   B'00100000',LATD; Turn ON RD5
0000A4 0E20               M         movlw  B'00100000'
0000A6 6E8C               M         movwf  LATD
0000A8 D???           00158         RCALL   Wait1s; call subroutine to wait 1 second
                      00159         MOVLF   B'00000000',LATD; Turn OFF RD5
0000AA 0E00               M         movlw  B'00000000'
0000AC 6E8C               M         movwf  LATD
                      00160         MOVLF   B'01000000',LATD; Turn ON RD6
0000AE 0E40               M         movlw  B'01000000'
0000B0 6E8C               M         movwf  LATD
0000B2 D???           00161         RCALL   Wait1s; call subroutine to wait 1 second
                      00162         MOVLF   B'00000000',LATD; Turn OFF RD6
0000B4 0E00               M         movlw  B'00000000'
0000B6 6E8C               M         movwf  LATD
                      00163         MOVLF   B'10000000',LATD; Turn ON RD7
0000B8 0E80               M         movlw  B'10000000'
0000BA 6E8C               M         movwf  LATD
0000BC D???           00164         RCALL   Wait1s; call subroutine to wait 1 second
                      00165         MOVLF   B'00000000',LATD; Turn OFF RD7
0000BE 0E00               M         movlw  B'00000000'
0000C0 6E8C               M         movwf  LATD
                      00166         
                      00167         MOVLF   B'00000000',INTCON
0000C2 0E00               M         movlw  B'00000000'
0000C4 6EF2               M         movwf  INTCON
                      00168         MOVLF   B'00001000',T0CON       ; Set up Timer0 for a delay of 10 ms
0000C6 0E08               M         movlw  B'00001000'
0000C8 6ED5               M         movwf  T0CON
                      00169         MOVLF   high Bignum10ms,TMR0H       ; Writing binary 25536 to TMR0H / TMR0L
0000CA 0E63               M         movlw  high Bignum10ms
0000CC 6ED7               M         movwf  TMR0H
                      00170         MOVLF   low Bignum10ms,TMR0L    ; Write high byte first, then low!
0000CE 0EC0               M         movlw  low Bignum10ms
0000D0 6ED6               M         movwf  TMR0L
0000D2 8ED5           00171         bsf     T0CON,7
                      00172         
0000D4 D???           00173         rcall   InitLCD                 ; Initialize LCD
0000D6 D???           00174         rcall   Wait10ms                ; 10 ms delay subroutine
                      00175         
                      00176         POINT   LCDcl                   ; Hello
                          M         MOVLF  high LCDcl,      TBLPTRH ; Used to put values in program memory
0000D8 0E??               M         movlw  high LCDcl
0000DA 6EF7               M         movwf  TBLPTRH
                          M         MOVLF  low LCDcl,      TBLPTRL
0000DC 0E??               M         movlw  low LCDcl
0000DE 6EF6               M         movwf  TBLPTRL
0000E0 D???           00177         rcall   DisplayC                ; Display character subroutine
                      00178         
0000E2 EE00 F017      00179         LFSR 0,PWMDISP
0000E6 D???           00180         rcall DisplayV
                      00181         
                      00182         MOVLF   B'00000000',INTCON
0000E8 0E00               M         movlw  B'00000000'
0000EA 6EF2               M         movwf  INTCON
                      00183         MOVLF   B'10000011',T0CON       ; Set up Timer0 for a delay of 250 ms
0000EC 0E83               M         movlw  B'10000011'
0000EE 6ED5               M         movwf  T0CON
                      00184         MOVLF   high Bignum,TMR0H       ; Writing binary 25536 to TMR0H / TMR0L
0000F0 0E0B               M         movlw  high Bignum
0000F2 6ED7               M         movwf  TMR0H
                      00185         MOVLF   low Bignum,TMR0L
0000F4 0EDC               M         movlw  low Bignum
0000F6 6ED6               M         movwf  TMR0L
                      00186         
                      00187         MOVLF   B'00000000',PIR1        ;Set up timers 1,3, and 5 for use in program
0000F8 0E00               M         movlw  B'00000000'
0000FA 6E9E               M         movwf  PIR1
                      00188         MOVLF   B'00000000',PIR2
0000FC 0E00               M         movlw  B'00000000'
0000FE 6EA1               M         movwf  PIR2
                      00189         MOVLF   B'00010011',T1CON
000100 0E13               M         movlw  B'00010011'
000102 6ECD               M         movwf  T1CON
                      00190         MOVLF   B'00000011',T3CON
000104 0E03               M         movlw  B'00000011'
000106 6EB1               M         movwf  T3CON
                      00191         MOVLF   B'00000011',T5CON
000108 0E03               M         movlw  B'00000011'
00010A 6E7B               M         movwf  T5CON
                      00192         
00010C 0012           00193         return
                      00194         
                      00195 ;;;;;;; InitLCD subroutine ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;THIS SUBROUTINE WAS BORROWED FROM THE LAB 4 EXAMPLE
                             CODE
                      00196 ;
                      00197 ; InitLCD - modified version of subroutine in Reference: Peatman CH7 LCD
                      00198 ; Initialize the LCD.
                      00199 ; First wait for 0.1 second, to get past display's power-on reset time.
                      00200 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                      00201         
00010E                00202 InitLCD
                      00203         MOVLF  10,COUNT     ; Wait 0.1 second for LCD to power up
00010E 0E0A               M         movlw  10
000110 6E0A               M         movwf  COUNT
000112                00204 Loop3
000112 D???           00205         rcall  Wait10ms     ; Call wait10ms 10 times to 0.1 second
000114 060A           00206         decf  COUNT,F
000116 E1??           00207         bnz     Loop3
000118 988A           00208         bcf     LATB,4      ; RS=0 for command mode to LCD
                      00209         POINT   LCDstr      ; Set up table pointer to initialization string
                          M         MOVLF  high LCDstr,     TBLPTRH ; Used to put values in program memory
00011A 0E??               M         movlw  high LCDstr
00011C 6EF7               M         movwf  TBLPTRH
                          M         MOVLF  low LCDstr,     TBLPTRL
00011E 0E??               M         movlw  low LCDstr
000120 6EF6               M         movwf  TBLPTRL
000122 0008           00210         tblrd*              ; Get first byte from string into TABLAT
000124                00211 Loop4
000124 6A8A           00212         clrf LATB           ; First set LATB to all zero        
000126 8A8A           00213         bsf   LATB,5        ; Drive E high - enable LCD
000128 50F5           00214         movf TABLAT,W       ; Move byte from program memory into working register
00012A 0BF0           00215         andlw 0xF0          ; Mask to get only upper nibble
00012C 38E8           00216         swapf WREG,W        ; Swap so that upper nibble is in right position to move to LATB (RB0:RB3)
00012E 1081           00217         iorwf PORTB,W       ; Mask with the rest of PORTB to retain existing RB7:RB4 states
000130 6E8A           00218         movwf LATB          ; Update LATB to send upper nibble
000132 9A8A           00219         bcf   LATB,5        ; Drive E low so LCD will process input
000134 D???           00220         rcall Wait10ms      ; Wait ten milliseconds
                      00221         
000136 6A8A           00222         clrf LATB           ; Reset LATB to all zero        
000138 8A8A           00223         bsf  LATB,5         ; Drive E high
00013A 50F5           00224         movf TABLAT,W,0     ; Move byte from program memory into working register
00013C 0B0F           00225         andlw 0x0F          ; Mask to get only lower nibble
00013E 1081           00226         iorwf PORTB,W,0     ; Mask lower nibble with the rest of PORTB
000140 6E8A           00227         movwf LATB,0        ; Update LATB to send lower nibble
000142 9A8A           00228         bcf   LATB,5        ; Drive E low so LCD will process input
000144 D???           00229         rcall Wait10ms      ; Wait ten milliseconds
000146 000B           00230         tblrd+*             ; Increment pointer and get next byte
000148 52F5           00231         movf  TABLAT,F      ; Check if we are done, is it zero?
00014A E1??           00232         bnz     Loop4
00014C 0012           00233         return
                      00234         
                      00235 ;;;;;;; T50 subroutine ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;THIS SUBROUTINE WAS BORROWED FROM THE LAB 4 EXAMPLE 
                            CODE
                      00236 ;
                      00237 ; T50 modified version of T40 taken from Reference: Peatman CH 7 LCD
                      00238 ; Pause for 50 microseconds or 50/0.25 = 200 instruction cycles.
                      00239 ; Assumes 16/4 = 4 MHz internal instruction rate (250 ns)
                      00240 ; rcall(2) + movlw(1) + movwf(1) + COUNT*3 - lastBNZ(1) + return(2) = 200 
                      00241 ; Then COUNT = 195/3
                      00242 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                      00243         
00014E                00244 T50
00014E 0E41           00245         movlw  195/3          ;Each loop L4 takes 3 ins cycles
000150 6E0A           00246         movwf  COUNT                
000152                00247 L4
000152 060A           00248         decf  COUNT,F
000154 E1??           00249         bnz     L4
000156 0012           00250         return
                      00251 ;;;;;;;;DisplayC subroutine;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; THIS SUBROUTINE WAS BORROWED FROM THE LAB 4 EXAMPLE 
                            CODE
                      00252 ; 
                      00253 ; DisplayC taken from Reference: Peatman CH7 LCD
                      00254 ; This subroutine is called with TBLPTR containing the address of a constant
                      00255 ; display string.  It sends the bytes of the string to the LCD.  The first
                      00256 ; byte sets the cursor position.  The remaining bytes are displayed, beginning
                      00257 ; at that position hex to ASCII.
                      00258 ; This subroutine expects a normal one-byte cursor-positioning code, 0xhh, and
                      00259 ; a null byte at the end of the string 0x00
                      00260 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                      00261 
000158                00262 DisplayC
000158 988A           00263         bcf   LATB,4            ;Drive RS pin low for cursor positioning code
00015A 0008           00264         tblrd*                  ;Get byte from string into TABLAT
00015C 52F5           00265         movf  TABLAT,F          ;Check for leading zero byte
00015E E1??           00266         bnz     Loop5
000160 000B           00267         tblrd+*                 ;If zero, get next byte
000162                00268 Loop5
000162 0EF0           00269         movlw 0xF0
000164 168A           00270         andwf LATB,F            ;Clear RB0:RB3, which are used to send LCD data
000166 8A8A           00271         bsf   LATB,5            ;Drive E pin high
000168 50F5           00272         movf TABLAT,W           ;Move byte from table latch to working register
00016A 0BF0           00273         andlw 0xF0              ;Mask to get only upper nibble
00016C 38E8           00274         swapf WREG,W            ;swap so that upper nibble is in right position to move to LATB (RB0:RB3)
00016E 1081           00275         iorwf PORTB,W           ;Mask to include the rest of PORTB
000170 6E8A           00276         movwf LATB              ;Send upper nibble out to LATB
000172 9A8A           00277         bcf   LATB,5            ;Drive E pin low so LCD will accept nibble
                      00278         
000174 0EF0           00279         movlw 0xF0
000176 168A           00280         andwf LATB,F            ;Clear RB0:RB3, which are used to send LCD data
000178 8A8A           00281         bsf   LATB,5            ;Drive E pin high again
00017A 50F5           00282         movf TABLAT,W           ;Move byte from table latch to working register
00017C 0B0F           00283         andlw 0x0F              ;Mask to get only lower nibble
00017E 1081           00284         iorwf PORTB,W           ;Mask to include the rest of PORTB
000180 6E8A           00285         movwf LATB              ;Send lower nibble out to LATB
000182 9A8A           00286         bcf   LATB,5            ;Drive E pin low so LCD will accept nibble
000184 D???           00287         rcall T50               ;Wait 50 usec so LCD can process
                      00288         
000186 888A           00289         bsf   LATB,4            ;Drive RS pin high for displayable characters
000188 000B           00290         tblrd+*                 ;Increment pointer, then get next byte
00018A 52F5           00291         movf  TABLAT,F          ;Is it zero?
00018C E1??           00292         bnz     Loop5
00018E 0012           00293         return
                      00294         
                      00295 ;;;;;;; DisplayV subroutine ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; THIS SUBROUTINE WAS BORROWED FROM THE LAB 4 EXAMPLE 
                            CODE
                      00296 ;
                      00297 ; DisplayV taken from Reference: Peatman CH7 LCD
                      00298 ; This subroutine is called with FSR0 containing the address of a variable
                      00299 ; display string.  It sends the bytes of the string to the LCD.  The first
                      00300 ; byte sets the cursor position.  The remaining bytes are displayed, beginning
                      00301 ; at that position.
                      00302 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
                      00303 
000190                00304 DisplayV
000190 988A           00305         bcf     LATB,4          ;Drive RS pin low for cursor positioning code
000192                00306 Loop6
000192 0EF0           00307         movlw 0xF0
000194 168A           00308         andwf LATB,F            ;Clear RB0:RB3, which are used to send LCD data
000196 8A8A           00309         bsf   LATB,5            ;Drive E pin high
000198 50EF           00310         movf INDF0,W            ;Move byte from table latch to working register
00019A 0BF0           00311         andlw 0xF0              ;Mask to get only upper nibble
00019C 38E8           00312         swapf WREG,W            ;swap so that upper nibble is in right position to move to LATB (RB0:RB3)
00019E 1081           00313         iorwf PORTB,W           ;Mask to include the rest of PORTB
0001A0 6E8A           00314         movwf LATB              ;Send upper nibble out to LATB
0001A2 9A8A           00315         bcf   LATB,5            ;Drive E pin low so LCD will accept nibble
                      00316         
0001A4 0EF0           00317         movlw 0xF0
0001A6 168A           00318         andwf LATB,F            ;Clear RB0:RB3, which are used to send LCD data
0001A8 8A8A           00319         bsf   LATB,5            ;Drive E pin high again
0001AA 50EF           00320         movf INDF0,W            ;Move byte from table latch to working register
0001AC 0B0F           00321         andlw 0x0F              ;Mask to get only lower nibble
0001AE 1081           00322         iorwf PORTB,W           ;Mask to include the rest of PORTB
0001B0 6E8A           00323         movwf LATB              ;Send lower nibble out to LATB
0001B2 9A8A           00324         bcf   LATB,5            ;Drive E pin low so LCD will accept nibble
0001B4 D???           00325         rcall T50               ;Wait 50 usec so LCD can process
                      00326           
0001B6 888A           00327         bsf   LATB,4            ;Drive RS pin high for displayable characters
0001B8 50EC           00328         movf  PREINC0,W         ;Increment pointer, then get next byte
0001BA E1??           00329         bnz     Loop6
0001BC 0012           00330         return  
                      00331 ;;;;;;; Wait1s subroutine ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; THIS SUBROUTINE WAS BORROWED FROM THE LAB 4 EXAMPLE 
                            CODE
                      00332 ;
                      00333 ; Subroutine to wait 1 second
                      00334                 
  00000BDC            00335 Bignum  equ     65536-62500             ;Used prescalar of 64
                      00336                     
                      00337   
0001BE                00338 Wait1s
0001BE A4F2           00339         btfss   INTCON,TMR0IF           ; Read Timer0 rollover flag and ...
0001C0 D???           00340         bra     Wait1s                  ; Loop if timer has not rolled over
                      00341         MOVLF   high Bignum,TMR0H       ; Then write the timer values into
0001C2 0E0B               M         movlw  high Bignum
0001C4 6ED7               M         movwf  TMR0H
                      00342         MOVLF   low Bignum,TMR0L        ; the timer high and low registers
0001C6 0EDC               M         movlw  low Bignum
0001C8 6ED6               M         movwf  TMR0L
0001CA 94F2           00343         bcf     INTCON,TMR0IF           ; Clear Timer0 rollover flag
0001CC 0012           00344         return
                      00345 
                      00346 ;;;;;;; Wait1sec subroutine ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                      00347 ;
                      00348 ; Subroutine to wait 1 sec based on calling WaitXXXms YYY times or up to 3 nested loops
                      00349                                 
                      00350         ;Need prescalar of 16
                      00351 
0001CE                00352 Wait250ms
0001CE A4F2           00353         btfss   INTCON,TMR0IF           ; Read Timer0 rollover flag and ...
0001D0 0012           00354         return
0001D2 788C           00355         BTG     LATD,4
                      00356         ;bra     Wait250ms              ; Loop if timer has not rolled over
                      00357         MOVLF   high Bignum,TMR0H       ; Then write the timer values into
0001D4 0E0B               M         movlw  high Bignum
0001D6 6ED7               M         movwf  TMR0H
                      00358         MOVLF   low Bignum,TMR0L        ; the timer high and low registers
0001D8 0EDC               M         movlw  low Bignum
0001DA 6ED6               M         movwf  TMR0L
0001DC 94F2           00359         bcf     INTCON,TMR0IF           ; Clear Timer0 rollover flag
0001DE 0012           00360         return
  000063C0            00361 Bignum10ms  equ 65536-40000
0001E0                00362 Wait10ms
0001E0 A4F2           00363         btfss   INTCON,TMR0IF           ; Read Timer0 rollover flag and ...
0001E2 D???           00364         bra     Wait10ms                ; Loop if timer has not rolled over
                      00365         MOVLF   high Bignum10ms,TMR0H       ; Then write the timer values into
0001E4 0E63               M         movlw  high Bignum10ms
0001E6 6ED7               M         movwf  TMR0H
                      00366         MOVLF   low Bignum10ms,TMR0L        ; the timer high and low registers
0001E8 0EC0               M         movlw  low Bignum10ms
0001EA 6ED6               M         movwf  TMR0L
0001EC 94F2           00367         bcf     INTCON,TMR0IF           ; Clear Timer0 rollover flag
0001EE 0012           00368         return
                      00369         
  00006B90            00370 Bignum1 equ     65536-38000
0001F0                00371 lowloop                                 ;Uses prescalar of 2
0001F0 A09E           00372         btfss   PIR1,TMR1IF           ; Read Timer1 rollover flag and ...
0001F2 0012           00373         return
                      00374         MOVLF   B'00000100',LATC
0001F4 0E04               M         movlw  B'00000100'
0001F6 6E8B               M         movwf  LATC
0001F8 C002 FFB3      00375         MOVFF   Bignum2high,TMR3H      ; Then write the timer values into
0001FC C003 FFB2      00376         MOVFF   Bignum2low,TMR3L       ; the timer high and low registers
000200 92A1           00377         bcf     PIR2,TMR3IF
000202 D???           00378         rcall   highloop
                      00379         ;bra     lowloop                     ; Loop if timer has not rolled over
                      00380         ;MOVLF  B'00000100',LATC
                      00381         ;MOVLF          high Bignum1,TMR1H      ; Then write the timer values into
                      00382         ;MOVLF          low Bignum1,TMR1L       ; the timer high and low registers
000204 909E           00383         bcf     PIR1,TMR1IF           ; Clear Timer1 rollover flag
                      00384         ;MOVLF  B'00000001',T3CON
                      00385         ;rcall  highloop
000206 0012           00386         return
  0000F060            00387 Bignum2 equ     65536-4000      
000208                00388 highloop
000208 A2A1           00389         btfss   PIR2,TMR3IF
00020A D???           00390         bra     highloop
                      00391         MOVLF   B'00000000',LATC        ; Read Timer3 rollover flag and ...
00020C 0E00               M         movlw  B'00000000'
00020E 6E8B               M         movwf  LATC
                      00392                                         ; Loop if timer has not rolled over
000210 C000 FFCF      00393         MOVFF   Bignum1high,TMR1H      ; Then write the timer values into
000214 C003 FFCE      00394         MOVFF   Bignum2low,TMR1L       ; the timer high and low registers
                      00395                                         ; Clear Timer3 rollover flag
000218 0012           00396         return
                      00397         ;btfss  PIR2,TMR3IF
                      00398         ;bra    highloop
                      00399         ;MOVLF  B'00000000',LATC        ; Read Timer3 rollover flag and ...
                      00400                                         ; Loop if timer has not rolled over
                      00401         ;MOVLF          high Bignum1,TMR1H      ; Then write the timer values into
                      00402         ;MOVLF          low Bignum1,TMR1L       ; the timer high and low registers
                      00403                                         ; Clear Timer3 rollover flag
                      00404         ;return
                      00405         
00021A                00406 Check_SW1
                      00407         ;BRA    pwmc
00021A A683           00408         BTFSS   PORTD,3 ; Add code here
00021C D???           00409         BRA     ds
00021E B612           00410         BTFSC   on,3
000220 D???           00411         BRA     ds
                      00412         MOVLF   high Bignum3,TMR5H       ; Then write the timer values into
000222 0E15               M         movlw  high Bignum3
000224 6E7D               M         movwf  TMR5H
                      00413         MOVLF   low Bignum3,TMR5L   
000226 0EA0               M         movlw  low Bignum3
000228 6E7C               M         movwf  TMR5L
00022A D???           00414         RCALL   Debounce
                      00415         MOVLF   B'00001000',on
00022C 0E08               M         movlw  B'00001000'
00022E 6E12               M         movwf  on
000230                00416 ds
000230 5083           00417         MOVF    PORTD,0 
000232 0B08           00418         ANDLW   B'00001000'
000234 5C12           00419         SUBWF   on,0
000236 B6E8           00420         BTFSC   WREG,3
000238 D???           00421         RCALL   pwmc
00023A 0012           00422                 return
  000015A0            00423 Bignum3 equ     65536-60000             
00023C                00424 Debounce
00023C A2BA           00425         btfss   PIR5,TMR5IF           ; Read Timer0 rollover flag and ...
00023E D???           00426         bra Debounce
                      00427                                       ; Loop if timer has not rolled over
                      00428         ;MOVLF          high Bignum3,TMR5H       ; Then write the timer values into
                      00429         ;MOVLF          low Bignum3,TMR5L        ; the timer high and low registers
000240 92BA           00430         bcf     PIR5,TMR5IF           ; Clear Timer0 rollover flag
000242 0012           00431         return
                      00432                 ;return
                      00433 
                      00434 ;Subroutine to increase duty cycle of PWM by adding 0.2ms to the high portion and subtracting 0.2ms from the low portion to keep the
                             
                      00435 ;period constant at 20ms                
000244                00436 pwmc
000244 748C           00437         BTG     LATD,2              ;If RD3 is pressed and released, increment the high portion of pwm by 0.2ms
                      00438         ;MOVLW  B'00000100'         ;and decrement low portion of pwm by 0.2ms
                      00439         ;cpfslt pwmcount,0
                      00440         ;bra    qr
                      00441         ;clrf   WREG
                      00442         ;MOVLW  B'00000101'
                      00443         ;cpfslt pwmcount,0
                      00444         ;bra    ps
000246 5001           00445         MOVF    Bignum1low,0
000248 2405           00446         ADDWF   deltabn1low,0
00024A 6E01           00447         MOVWF   Bignum1low,0
00024C 5000           00448         MOVF    Bignum1high,0
00024E 2004           00449         ADDWFC  deltabn1high,0
000250 6E00           00450         MOVWF   Bignum1high,0
000252 5007           00451         MOVF    deltabn2low,0
000254 5C03           00452         SUBWF   Bignum2low,0
000256 6E03           00453         MOVWF   Bignum2low,0
000258 5002           00454         MOVF    Bignum2high,0
00025A 5406           00455         SUBFWB  deltabn2high,0
00025C 6E02           00456         MOVWF   Bignum2high,0
00025E 0E04           00457         MOVLW   B'00000100'         ;Check if the pwm is ready to be reset to high for 1ms and low for 19ms yet
000260 6014           00458         cpfslt  pwmcount,0
000262 D???           00459         bra     qr
000264 2A1D           00460         INCF    PWMDISP+6,F
000266 2A1D           00461         INCF    PWMDISP+6,F
000268 EE00 F017      00462         LFSR    0,PWMDISP
00026C D???           00463         rcall   DisplayV
00026E 2A14           00464         INCF    pwmcount,1
000270 6A12           00465         CLRF    on
000272 0012           00466         return
                      00467         
000274                00468 qr
000274 6214           00469         cpfseq  pwmcount,0          ;Adusting LCD to change from 1.80 to 2.00 when appropriate
000276 D???           00470         bra     ps
000278 2A1B           00471         INCF    PWMDISP+4
                      00472         MOVLF   0x30,PWMDISP+6
00027A 0E30               M         movlw  0x30
00027C 6E1D               M         movwf  PWMDISP+6
                      00473         MOVLF   0x30,PWMDISP+6
00027E 0E30               M         movlw  0x30
000280 6E1D               M         movwf  PWMDISP+6
000282 EE00 F017      00474         LFSR    0,PWMDISP
000286 D???           00475         rcall   DisplayV
000288 2A14           00476         INCF    pwmcount,1
00028A 6A12           00477         clrf    on
00028C 0012           00478         return
00028E                00479 ps
                      00480         MOVLF   high Bignum1,Bignum1high    ;Reset pwm to 1ms high and 19ms low from 2ms high and 18ms low
00028E 0E6B               M         movlw  high Bignum1
000290 6E00               M         movwf  Bignum1high
                      00481         MOVLF   low Bignum1,Bignum1low
000292 0E90               M         movlw  low Bignum1
000294 6E01               M         movwf  Bignum1low
                      00482         MOVLF   high Bignum2,Bignum2high
000296 0EF0               M         movlw  high Bignum2
000298 6E02               M         movwf  Bignum2high
                      00483         MOVLF   low Bignum2,Bignum2low
00029A 0E60               M         movlw  low Bignum2
00029C 6E03               M         movwf  Bignum2low
                      00484         MOVLF   0x31,PWMDISP+4
00029E 0E31               M         movlw  0x31
0002A0 6E1B               M         movwf  PWMDISP+4
0002A2 EE00 F017      00485         LFSR    0,PWMDISP   
0002A6 D???           00486         rcall   DisplayV
0002A8 6A14           00487         clrf    pwmcount
0002AA 6A12           00488         clrf    on
0002AC 0012           00489         return
                      00490                                                                                 ;THIS SUBROUTINE WAS BORROWED FROM THE LAB 4 EXAMPLE
                             CODE
0002AE                00491 ByteDisplay
                      00492         POINT   LCDcl                 ;Display "BYTE="
                          M         MOVLF  high LCDcl,      TBLPTRH ; Used to put values in program memory
0002AE 0E??               M         movlw  high LCDcl
0002B0 6EF7               M         movwf  TBLPTRH
                          M         MOVLF  low LCDcl,      TBLPTRL
0002B2 0E??               M         movlw  low LCDcl
0002B4 6EF6               M         movwf  TBLPTRL
0002B6 D???           00493         rcall   DisplayC
0002B8 EE00 F015      00494         lfsr    0,BYTESTR+8
0002BC                00495 L10
0002BC 6AE8           00496           clrf  WREG
0002BE 320C           00497           rrcf  BYTE,F                 ;Move bit into carry
0002C0 36E8           00498           rlcf  WREG,F                 ;and from there into WREG
0002C2 0930           00499           iorlw 0x30                   ;Convert to ASCII
0002C4 6EED           00500           movwf POSTDEC0               ; and move to string
0002C6 50E9           00501           movf  FSR0L,W                ;Done?
0002C8 080D           00502           sublw low BYTESTR
0002CA E1??           00503         bnz     L10
                      00504 
0002CC EE00 F00D      00505         lfsr    0,BYTESTR              ;Set pointer to display string
                      00506         MOVLF   0xc0,BYTESTR           ;Add cursor-positioning code
0002D0 0EC0               M         movlw  0xc0
0002D2 6E0D               M         movwf  BYTESTR
0002D4 6A16           00507         clrf    BYTESTR+9              ;and end-of-string terminator
0002D6 D???           00508         rcall   DisplayV
0002D8 0012           00509         return
                      00510 ;;;;;;; Constant strings ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002DA 3233 0128 060C 00511 LCDstr  db  0x33,0x32,0x28,0x01,0x0c,0x06,0x00  ;Initialization string for LCD
       0000 
0002E2 4280 5459 3D45 00512 BYTE_1  db  "\x80BYTE=   \x00"         ;Write "BYTE=" to first line of LCD
       2020 0020 
0002EC 4180 4553 204E 00513 LCDcl   db  "\x80ASEN 5067   \x00"
       3035 3736 2020 
       0020 
0002FA 4880 6C65 6F6C 00514 LCDs    db  "\x80Hello\x00"
       0000 
000302 57C0 726F 646C 00515 LCDs2   db  "\xC0World!\x00"
       0021 
                      00516 ;;;;;;; End of Program ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                      00517         end

Errors   :     0
Warnings :     0 reported,     0 suppressed
Messages :     0 reported,     0 suppressed

